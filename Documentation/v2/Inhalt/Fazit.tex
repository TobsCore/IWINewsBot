\chapter{Fazit}
Im Laufe dieser Projektarbeit konnten ausgiebig Erfahrungen für den Aufbau eines Chatbots mit Rivescript gesammelt werden. Die Vor- und Nachteile werden im Folgenden beschrieben. Außerdem wird aus dem Proof-of-Concept der Sprachnachrichten ein Resümmee gezogen. Im letzten Abschnitt wird ein mögliches weiteres Vorgehen beleuchtet.

\section{Bewertung}
Rivescript hat sehr schnell durch seine Einfachheit überzeugt. Das Einbinden der Bibliothek war nicht unnötig kompliziert und das Matchen von Eingabe auf Ausgabe ist sehr intuitiv. Die Einarbeitung gelang somit schnell. Die Routinen sind für etwas komplexere Chatbot-Systeme unbedingt notwendig, es ist aber nett, dass man simple Anfragen in den \texttt{.rive}-Dateien direkt beantworten kann. Besonders praktisch zur Strukturierung hierbei war, dass man mehrere \texttt{.rive}-Dateien definieren kann.\\
Ein tolles Konzept in Rivescript ist der Einsatz von Arrays und Ersetzungen (\textit{Substitutions}), die es erlauben, kompaktere Eingaben zu matchen und Komplexität zu eliminieren. Außerdem sind \textit{Kontexte} ein tolles Hilfsmittel um \textit{State} zu simulieren.

Rivescript ist jedoch keine vollständig programmierbare Sprache, es ist häufig notwendig Routinen einzusetzen um Probleme zu lösen. Dies ist für Personen, die keine tieferen Programmierkenntnisse besitzen, aber einen Chatbot entwickeln möchten, ein Nachteil, der für dieses Projekt jedoch nicht zum Tragen kam. Vielmehr störte, dass die Parameter für die Routinen-Aufrufe nicht einfach waren, da in Rivescript alles ein String ist. Dies führte vor allem bei Parametern, die aus mehreren Wörtern bestehen zu Problemen. Außerdem wäre ein eigenes Rivescript Logging praktisch, da der Use-Case des Suchens nach fehlenden Formulierungen vermutlich nicht dieses Projekt betrifft. \\
Rivescript bietet viele Möglichkeiten zu matchen; hier wären Best Practices sinnvoll, die aufzeigen, ob der Einsatz von eigenen Routinen oder die Auswertung von Parametern zu bevorzugen ist.\\
Der Support von UTF-8 sollte in der heutigen Zeit keine Ausnahme mehr sein, sondern Standard, somit war es verwunderlich, dass diese Funktionalität als \textit{experimentell} deklarier wurde. Und tatsächlich wurden Umlaute auf Windows-Systemen nicht korrekt dargestellt, was während der Entwicklung und des Testens zu Verwirrung führte und die Entwicklungsprozess zudem behinderte.\\
Ein weiteres Problem war das Finden von Fehlern. Rivescript setzt ausschließlich auf Strings und so werden auch Fehler als Textmeldung zurückgegeben. Der Einsatz von Exceptions oder ein insgesamt runderes Fehlermanagement wäre wünschenswert. Dies hat einen engen Bezug zu einem weiteren Kritikpunkt: Wenn eine Eingabe auf 2 mögliche Fälle matcht ist nicht klar, auf welchen Fall gemacht wird. Dies erschwert zusätzlich die Fehlersuche.\\
Zuletzt sind die regulären Ausdrücke, die zum Matchen genutzt werden, nicht sehr performant. Der User bekommt dies zwar nicht mit, da das Finden einer Antwort in unter 50ms geschieht, diese Wartezeit ist jedoch bei mehreren gleichzeitigen Anfragen ein Problem.\\
Zuletzt wäre es wünschenswert, nicht nur mehrere Ausgaben auf eine Eingabe zu matchen, sondern auch mehrere Eingaben auf die gleiche Ausgabe zu matchen. Dies würde die \texttt{.rive}-Dateien übersichtlicher machen.

Somit bietet Rivescript zwar als Framework einen einfachen Einstieg in die Entwicklung von funktionalen Chatbots, als System für aufwendige und komplexe Anwendungen eignet es sich jedoch aufgrund der genannten Gründe nicht. Der IWINewsBot liegt in seiner Komplexität nicht mehr im einfachen Bereich und somit stießen wir auch an die Grenzen des Frameworks.

Die Umwandlung von Sprache zu Text ist bekannterweise nicht einfach und somit ist es toll, dass Google diesen Service anbietet. Die Integration war nach einer ersten Einarbeitung nicht schwierig, obwohl sich das Projekt noch im Alpha-Stadium befindet. Der Service versteht die Sprache zuverlässig.
Dadurch, dass Telegram vor allem im mobilen Umfeld genutzt wird, ist ein solche Feature besonders praktisch, da das Tippen auf mobilen Geräten nicht so genau und einfach ist, wie auf einer gewöhnlichen Tastatur. Ob der Einsatz von Google Services die Kosten sprengen würde, wird in dieser Projektarbeit nicht weiter betrachtet, da von vornherein die Implementierung als Proof of Concept gesehen wurde.

Dass Telegram unterschiedliche Dateiformate nutzt ist auf den ersten Blick nicht intuitiv, hier ist aber auch Google nicht ganz unschuldig, da die Frequenz einer Audiodatei auf Serverseite erkannt werden sollte, diese Einstellungsmöglichkeit sollte nicht dem Nutzer überlassen werden.

Insgesamt ist es aber sehr praktisch, dass man Sprachnachrichten auch an Bots senden kann, diese können somit noch umfangreichere Aufgaben übernehmen.

\section{Ausblick}
Man kann davon ausgehen, dass nicht alle möglichen Formulierungen und Fragen der Benutzer vom Bot abgedeckt sind. Dies kann erst nach der Produktivsetzung des Bots, wenn der Zugriff mehr Leuten möglich ist, festgestellt werden. Interessant wäre also die nicht erkannten Formulierungen der Benutzer auszuwerten und so den Bot kontinuierlich zu verbessern. Die dafür notwendige Logging-Funktion ist dafür schon implementiert.

Allgemein könnten die Ausgaben des Bots an die Benutzer noch konkretisiert werden. Die Stundenplanausgabe von Studierenden, die sich im sechsten Semester im Bachelor befinden, ist eigentlich nicht sinnvoll, da dies hauptsächlich aus Wahlfächern besteht. In diese Richtung ist theoretisch noch Verbessungsspielraum.
Es stellt sich jedoch die Frage, ob der Funktionsumfang dann nicht den Sinn übersteigt. Durch die eingeschränkten Styling- und Kommunikationsfunktionen eines Telegram-Bots kann es eher eine User-Experience-Hölle sein. Daher ist es nicht sinnvoll für einen Bot, die Möglichkeit eines selbst zusammengestellten Stundenplans zu geben.

%TODO basic authentification option?
